---
layout : post
title: Redis简介
category : Redis
duoshuo: true
math: true
date : 2015-1-7
---

<!-- more -->
 
Redis是一个高性能的key-value内存数据库，官网：[http://redis.io/](http://redis.io/)。
##Redis支持的数据类型
Redis支持的数据类型有：
>
- strings：字符串是一种最基本的Redis值类型。Redis字符串是二进制安全的，这意味着一个Redis字符串能包含任意类型的数据，
一个字符串类型的值最多能存储512M字节的内容。
- hashes：Redis Hashes是字符串字段和字符串值之间的映射，所以它们是完美的表示对象（eg:一个有名，姓，年龄等属性的用户）的数据类型。
一个hash最多可以包含232-1 字段-值对（超过40亿）。
- lists：Redis列表是简单的字符串列表，按照插入顺序排序。 你可以添加一个元素到列表的头部（左边）或者尾部（右边）。
LPUSH命令插入一个新元素到列表头部，而RPUSH命令 插入一个新元素到列表的尾部。一个列表最多可以包含232-1个元素（4294967295，每个表超过40亿个元素）。
- sets：Redis集合是一个无序的字符串合集。你可以以O(1) 的时间复杂度（无论集合中有多少元素时间复杂度都为常量）完成 添加，删除以及测试元素是否存在的操作。
Redis集合有着不允许相同成员存在的优秀特性。向集合中多次添加同一元素，在集合中最终只会存在一个此元素。实际上这就意味着，在添加元素前，你并不需要事先进行检验此元素是否已经存在的操作。
一个集合最多可以包含232-1个元素（4294967295，每个集合超过40亿个元素）。
- sorted sets：Redis有序集合和Redis集合类似，是不包含 相同字符串的合集。它们的差别是，每个有序集合 的成员都关联着一个评分，这个评分用于把有序集 合中的成员按最低分到最高分排列。
使用有序集合，你可以非常快地（O(log(N))）完成添加，删除和更新元素的操作。 因为元素是在插入时就排好序的，所以很快地通过评分(score)或者 位次(position)获得一个范围的元素。 访问有序集合的中间元素同样也是非常快的，因此你可以使用有序集合作为一个没用重复成员的智能列表。 在这个列表中， 你可以轻易地访问任何你需要的东西: 有序的元素，快速的存在性测试，快速访问集合中间元素！

##Redis的一些使用场景
1．在主页中显示最新的项目列表。
    Redis使用的是常驻内存的缓存，速度非常快。LPUSH用来插入一个内容ID，作为关键字存储在列表头部。LTRIM用来限制列表中的项目数最多为5000。如果用户需要的检索的数据量超越这个缓存容量，这时才需要把请求发送到数据库。

2．删除和过滤。
    如果一篇文章被删除，可以使用LREM从缓存中彻底清除掉。

3．排行榜及相关问题。
    排行榜（leader board）按照得分进行排序。ZADD命令可以直接实现这个功能，而ZREVRANGE命令可以用来按照得分来获取前100名的用户，ZRANK可以用来获取用户排名，非常直接而且操作容易。

4．按照用户投票和时间排序。
    这就像Reddit的排行榜，得分会随着时间变化。LPUSH和LTRIM命令结合运用，把文章添加到一个列表中。一项后台任务用来获取列表，并重新计算列表的排序，ZADD命令用来按照新的顺序填充生成列表。列表可以实现非常快速的检索，即使是负载很重的站点。

5．过期项目处理。
    使用unix时间作为关键字，用来保持列表能够按时间排序。对current_time和time_to_live进行检索，完成查找过期项目的艰巨任务。另一项后台任务使用ZRANGE...WITHSCORES进行查询，删除过期的条目。

6．计数。
    进行各种数据统计的用途是非常广泛的，比如想知道什么时候封锁一个IP地址。INCRBY命令让这些变得很容易，通过原子递增保持计数；GETSET用来重置计数器；过期属性用来确认一个关键字什么时候应该删除。

7．特定时间内的特定项目。
    这是特定访问者的问题，可以通过给每次页面浏览使用SADD命令来解决。SADD不会将已经存在的成员添加到一个集合。

8．实时分析正在发生的情况，用于数据统计与防止垃圾邮件等。
    使用Redis原语命令，更容易实施垃圾邮件过滤系统或其他实时跟踪系统。

9．Pub/Sub。
    在更新中保持用户对数据的映射是系统中的一个普遍任务。Redis的pub/sub功能使用了SUBSCRIBE、UNSUBSCRIBE和PUBLISH命令，让这个变得更加容易。

10．队列。
    在当前的编程中队列随处可见。除了push和pop类型的命令之外，Redis还有阻塞队列的命令，能够让一个程序在执行时被另一个程序添加到队列。你也可以做些更有趣的事情，比如一个旋转更新的RSS feed队列。

11．缓存。
    Redis缓存使用的方式与memcache相同。

##Redis数据库的配置
>
1、daemonize：是否以后台进程运行，默认为no，如果需要以后台进程运行则改为yes
2、pidfile：当Redis在后台运行的时候，Redis默认会把pid文件放在/var/run/redis.pid，你可以配置到其他地址。当运行多个redis服务时，需要指定不同的pid文件和端口。
3、bind：指定Redis只接收来自于该IP地址的请求，如果不进行设置，那么将处理所有请求，**在生产环境中建议设置该项**。
4、port：监听端口，默认为6379。
5、timeout：设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接。
6、loglevel：log等级分为4级，debug（很详细的信息，适合开发和测试）, verbose（包含许多不太有用的信息，但比debug要清爽一些）, notice（比较适合生产环境）, 和warning（警告信息）。生产环境下一般开启notice。
7、logfile：配置log文件地址，默认使用标准输出，即打印在命令行终端的窗口上。
8、databases：设置数据库的个数，可以使用SELECT 命令来切换数据库。默认使用的数据库是0。
9、save：设置Redis进行数据库镜像的频率。例如：
    save 900 1   :过了900秒并且有1个key发生了改变 就会触发save动作
    save 300 10  :过了300秒并且有10个key发生了改变 就会触发save动作
    save 60 10000:过了60秒并且至少有10000个key发生了改变 也会触发save动作
10、rdbcompression：在进行镜像备份时，是否进行压缩。
11、dbfilename：镜像备份文件的文件名。
12、dir：数据库镜像备份的文件放置的路径。这里的路径跟文件名要分开配置是因为Redis在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成时，再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中。
13、slaveof：设置该数据库为其他数据库的从数据库。
14、masterauth：当主数据库连接需要密码验证时，在这里指定。
15、requirepass：设置客户端连接后进行任何其他指定前需要使用的密码。警告：因为redis速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行150K次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解。
16、maxclients：限制同时连接的客户数量。当连接数超过这个值时，redis将不再接收其他连接请求，客户端尝试连接时将收到error信息。
17、maxmemory：设置redis能够使用的最大内存。当内存满了的时候，如果还接收到set命令，redis将先尝试剔除设置过expire信息的key，而不管该key的过期时间还没有到达。在删除时，将按照过期时间进行删除，最早将要被过期的key将最先被删除。如果带有expire信息的key都删光了，那么将返回错误。这样，redis将不再接收写请求，只接收get请求。maxmemory的设置比较适合于把redis当作于类似memcached的缓存来使用。
18、appendonly：默认情况下，redis会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。所以redis提供了另外一种更加高效的数据库备份及灾难恢复方式。开启append only模式之后，redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态。但是这样会造成appendonly.aof文件过大，所以redis还支持了BGREWRITEAOF指令，对appendonly.aof进行重新整理。所以我认为推荐生产环境下的做法为关闭镜像，开启appendonly.aof，同时可以选择在访问较少的时间每天对appendonly.aof进行重写一次。
19、appendfsync：设置对appendonly.aof文件进行同步的频率。always表示每次有写操作都进行同步，everysec表示对写操作进行累积，每秒同步一次。这个需要根据实际业务场景进行配置。
20、vm-enabled：是否开启虚拟内存支持。因为redis是一个内存数据库，而且当内存满的时候，无法接收新的写请求，所以在redis 2.0中，提供了虚拟内存的支持。但是需要注意的是，redis中，所有的key都会放在内存中，在内存不够时，只会把value值放入交换区。这样保证了虽然使用虚拟内存，但性能基本不受影响，同时，你需要注意的是你要把vm-max-memory设置到足够来放下你的所有的key。
21、vm-swap-file：设置虚拟内存的交换文件路径。
22、vm-max-memory：这里设置开启虚拟内存之后，redis将使用的最大物理内存的大小。默认为0，redis将把他所有的能放到交换文件的都放到交换文件中，以尽量少的使用物理内存。在生产环境下，需要根据实际情况设置该值，最好不要使用默认的0。
23、vm-page-size：设置虚拟内存的页大小，如果你的value值比较大，比如说你要在value中放置博客、新闻之类的所有文章内容，就设大一点，如果要放置的都是很小的内容，那就设小一点。
24、vm-pages：设置交换文件的总的page数量，需要注意的是，page table信息会放在物理内存中，每8个page就会占据RAM中的1个byte。总的虚拟内存大小 = vm-page-size * vm-pages。
25、vm-max-threads：设置VM IO同时使用的线程数量。因为在进行内存交换时，对数据有编码和解码的过程，所以尽管IO设备在硬件上本上不能支持很多的并发读写，但是还是如果你所保存的vlaue值比较大，将该值设大一些，还是能够提升性能的。
26、activerehashing：开启之后，redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存。
27、stop-writes-on-bgsave-error：如果后台进程或服务发生错误是否继续写操作。
28、rdbchecksum：是否开启数据校验，开启的话在保存和加载的时候将会牺牲10%左右的性能。
29、slave-serve-stale-data：当主从数据库之间连接断开，或从数据库正在处理请求时，从数据库将会作出两种回应：此设置为YES(默认)时，将会返回过时的数据或空；此设置为NO的话，将返回错误“SYNC with master in progress”
30、slave-read-only：从数据库是否只读。
31、repl-ping-slave-period：从数据库想住数据库发送Ping命令的间隔，默认为10S。
32、 repl-timeout：各种连接或操作的超时时间，通常需要设置的比较大。
33、slave-priority：从数据库的优先级，以数字表示，数字越小优先级越高，当主数据库发生意外停止运行时，将启动优先级最高的从数据库作为新的主数据库。
34、repl-disable-tcp-nodelay：数据传输延时，如果开启的话，从数据库可以以更小的数据大小向主数据库发送数据。
35、maxheap：最大堆大小。
36、no-appendfsync-on-rewrite：指定是否在后台aof文件rewrite期间调用fsync，默认为no，表示要调用fsync（无论后台是否有子进程在刷盘）。Redis在后台写RDB文件或重写afo文件期间会存在大量磁盘IO，此时，在某些linux系统中，调用fsync可能会阻塞。
37、auto-aof-rewrite-percentage：指定Redis重写aof文件的条件，默认为100，表示与上次rewrite的aof文件大小相比，当前aof文件增长量超过上次afo文件大小的100%时，就会触发background rewrite。若配置为0，则会禁用自动rewrite。
38、auto-aof-rewrite-min-size：指定触发rewrite的aof文件大小。若aof文件小于该值，即使当前文件的增量比例达到auto-aof-rewrite-percentage的配置值，也不会触发自动rewrite。即这两个配置项同时满足时，才会触发rewrite。
39、aof-rewrite-incremental-fsync：aof rewrite过程中,是否采取增量文件同步策略,默认为“yes”。 rewrite过程中,每32M数据进行一次文件同步,这样可以减少aof大文件写入对磁盘的操作次数。





参考文献：
【1】[http://langgufu.iteye.com/blog/1434408](http://langgufu.iteye.com/blog/1434408)

【2】[http://www.redis.cn/topics/data-types.html#sorted-sets](http://www.redis.cn/topics/data-types.html#sorted-sets)

【3】[http://highscalability.com/blog/2011/7/6/11-common-web-use-cases-solved-in-redis.html](http://highscalability.com/blog/2011/7/6/11-common-web-use-cases-solved-in-redis.html)

